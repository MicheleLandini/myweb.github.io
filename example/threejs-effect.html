<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cosmos Drift — Three.js</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000;
      overflow: hidden;
      font-family: 'Courier New', monospace;
    }

    canvas { display: block; }

    #ui {
      position: fixed;
      bottom: 32px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 10;
    }

    .btn {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.15);
      color: rgba(255,255,255,0.7);
      padding: 8px 20px;
      font-family: 'Courier New', monospace;
      font-size: 11px;
      letter-spacing: 2px;
      text-transform: uppercase;
      cursor: pointer;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }

    .btn:hover, .btn.active {
      background: rgba(255,255,255,0.12);
      border-color: rgba(255,255,255,0.5);
      color: #fff;
    }

    #title {
      position: fixed;
      top: 32px;
      left: 40px;
      color: rgba(255,255,255,0.25);
      font-size: 11px;
      letter-spacing: 4px;
      text-transform: uppercase;
      z-index: 10;
    }

    #title span {
      display: block;
      font-size: 9px;
      letter-spacing: 2px;
      margin-top: 4px;
      color: rgba(255,255,255,0.12);
    }
  </style>
</head>
<body>

<div id="title">
  Cosmos Drift
  <span>three.js · particle field</span>
</div>

<div id="ui">
  <button class="btn active" onclick="setMode('sphere')">Sfera</button>
  <button class="btn" onclick="setMode('ml')">ML</button>
  <button class="btn" onclick="setMode('galaxy')">Galassia</button>
  <button class="btn" onclick="setMode('chaos')">Caos</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ── Scene Setup ────────────────────────────────────────────────────────────
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
camera.position.set(0, 0, 5);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// ── Particle Config ────────────────────────────────────────────────────────
const COUNT = 8000;
const positions = new Float32Array(COUNT * 3);
const targets   = new Float32Array(COUNT * 3);
const colors    = new Float32Array(COUNT * 3);
const speeds    = new Float32Array(COUNT);

for (let i = 0; i < COUNT; i++) speeds[i] = 0.005 + Math.random() * 0.015;

// Color palette: deep indigo → cyan → white
const palette = [
  new THREE.Color('#c8b6ff'),
  new THREE.Color('#93e4f5'),
  new THREE.Color('#ffffff'),
  new THREE.Color('#ff9de2'),
  new THREE.Color('#a8d8ff'),
];

for (let i = 0; i < COUNT; i++) {
  const c = palette[Math.floor(Math.random() * palette.length)];
  colors[i * 3]     = c.r;
  colors[i * 3 + 1] = c.g;
  colors[i * 3 + 2] = c.b;
}

// ── Target Generators ──────────────────────────────────────────────────────
function genSphere(out) {
  for (let i = 0; i < COUNT; i++) {
    const phi   = Math.acos(2 * Math.random() - 1);
    const theta = Math.random() * Math.PI * 2;
    const r     = 2 + (Math.random() - 0.5) * 0.3;
    out[i * 3]     = r * Math.sin(phi) * Math.cos(theta);
    out[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
    out[i * 3 + 2] = r * Math.cos(phi);
  }
}

function genML(out) {
  // Draw "ML" using line segments sampled with particles
  // Each letter defined as polyline segments [x, y] in a -1..1 space
  const M = [
    // M: 5 points
    [-1, -1], [-1, 1], [-0.5, 0], [0, 1], [0, -1]
  ];
  const L = [
    [-0.7, 1], [-0.7, -1], [0.3, -1]
  ];

  // Build segment list with lengths for weighted sampling
  function getSegments(pts) {
    const segs = [];
    for (let i = 0; i < pts.length - 1; i++) {
      const ax = pts[i][0], ay = pts[i][1];
      const bx = pts[i+1][0], by = pts[i+1][1];
      const len = Math.hypot(bx - ax, by - ay);
      segs.push({ ax, ay, bx, by, len });
    }
    return segs;
  }

  function totalLen(segs) { return segs.reduce((s, sg) => s + sg.len, 0); }

  function sampleSegments(segs, n, offsetX, out, start) {
    const total = totalLen(segs);
    for (let i = 0; i < n; i++) {
      let r = Math.random() * total;
      for (const sg of segs) {
        if (r <= sg.len) {
          const t = r / sg.len;
          const x = (sg.ax + (sg.bx - sg.ax) * t) * 1.1 + offsetX;
          const y = (sg.ay + (sg.by - sg.ay) * t) * 1.1;
          const idx = (start + i) * 3;
          out[idx]     = x;
          out[idx + 1] = y;
          out[idx + 2] = (Math.random() - 0.5) * 0.08;
          break;
        }
        r -= sg.len;
      }
    }
  }

  const mSegs = getSegments(M);
  const lSegs = getSegments(L);
  const half = Math.floor(COUNT / 2);

  sampleSegments(mSegs, half,     -1.3, out, 0);
  sampleSegments(lSegs, COUNT - half, 1.1, out, half);
}

function genGalaxy(out) {
  for (let i = 0; i < COUNT; i++) {
    const arm    = Math.floor(Math.random() * 3);
    const t      = Math.random();
    const angle  = t * Math.PI * 4 + (arm * Math.PI * 2) / 3;
    const radius = 0.3 + t * 2.5;
    const spread = (1 - t) * 0.2 + 0.05;
    out[i * 3]     = Math.cos(angle) * radius + (Math.random() - 0.5) * spread;
    out[i * 3 + 1] = (Math.random() - 0.5) * 0.25;
    out[i * 3 + 2] = Math.sin(angle) * radius + (Math.random() - 0.5) * spread;
  }
}

function genChaos(out) {
  for (let i = 0; i < COUNT; i++) {
    out[i * 3]     = (Math.random() - 0.5) * 6;
    out[i * 3 + 1] = (Math.random() - 0.5) * 6;
    out[i * 3 + 2] = (Math.random() - 0.5) * 6;
  }
}

const generators = { sphere: genSphere, ml: genML, galaxy: genGalaxy, chaos: genChaos };

// Init positions to random
genChaos(positions);
genSphere(targets);

// ── Geometry & Material ────────────────────────────────────────────────────
const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color',    new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({
  size: 0.018,
  vertexColors: true,
  transparent: true,
  opacity: 0.85,
  sizeAttenuation: true,
  depthWrite: false,
  blending: THREE.AdditiveBlending,
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

// ── Fog & Glow ─────────────────────────────────────────────────────────────
scene.fog = new THREE.FogExp2(0x000000, 0.05);

// Background stars (tiny, static)
const starGeo = new THREE.BufferGeometry();
const starPos = new Float32Array(3000 * 3);
for (let i = 0; i < starPos.length; i++) starPos[i] = (Math.random() - 0.5) * 80;
starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
const starMat = new THREE.PointsMaterial({ size: 0.04, color: 0xaaaacc, transparent: true, opacity: 0.4, depthWrite: false });
scene.add(new THREE.Points(starGeo, starMat));

// ── Mouse Interaction ──────────────────────────────────────────────────────
let mouse = { x: 0, y: 0 };
document.addEventListener('mousemove', e => {
  mouse.x = (e.clientX / innerWidth - 0.5) * 2;
  mouse.y = -(e.clientY / innerHeight - 0.5) * 2;
});

// Touch support
document.addEventListener('touchmove', e => {
  const t = e.touches[0];
  mouse.x = (t.clientX / innerWidth - 0.5) * 2;
  mouse.y = -(t.clientY / innerHeight - 0.5) * 2;
}, { passive: true });

// ── Mode Switch ────────────────────────────────────────────────────────────
window.setMode = function(mode) {
  document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');
  generators[mode](targets);
};

// ── Resize ─────────────────────────────────────────────────────────────────
window.addEventListener('resize', () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

// ── Animation Loop ─────────────────────────────────────────────────────────
let t = 0;
const posAttr = geometry.attributes.position;

function animate() {
  requestAnimationFrame(animate);
  t += 0.005;

  // Lerp particles toward targets
  for (let i = 0; i < COUNT; i++) {
    const s = speeds[i];
    positions[i * 3]     += (targets[i * 3]     - positions[i * 3])     * s;
    positions[i * 3 + 1] += (targets[i * 3 + 1] - positions[i * 3 + 1]) * s;
    positions[i * 3 + 2] += (targets[i * 3 + 2] - positions[i * 3 + 2]) * s;
  }
  posAttr.needsUpdate = true;

  // Slow rotation driven by mouse
  particles.rotation.y += 0.0015 + mouse.x * 0.0005;
  particles.rotation.x += mouse.y * 0.0003;

  // Gentle breathing scale
  const breathe = 1 + Math.sin(t * 0.8) * 0.03;
  particles.scale.setScalar(breathe);

  // Pulse opacity
  material.opacity = 0.7 + Math.sin(t * 1.2) * 0.15;

  renderer.render(scene, camera);
}

animate();
</script>
</body>
</html>
